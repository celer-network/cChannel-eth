// Code generated by protoc-gen-sol. DO NOT EDIT.
// source: contracts/lib/data/proto/guard.proto
pragma solidity ^0.5.0;

import "./Pb.sol";

library PbGuard {
    using Pb for Pb.Buffer;  // so we can call Pb funcs on Buffer obj

    struct Node {
        bytes[] childs;   // tag: 1
    } // end struct Node

    function decNode(bytes memory raw) internal pure returns (Node memory m) {
        Pb.Buffer memory buf = Pb.fromBytes(raw);

        uint[] memory cnts = buf.cntTags(1);
        m.childs = new bytes[](cnts[1]);
        cnts[1] = 0;  // reset counter for later use
        
        uint tag;
        Pb.WireType wire;
        while (buf.hasMore()) {
            (tag, wire) = buf.decKey();
            if (false) {} // solidity has no switch/case
            else if (tag == 1) {
                m.childs[cnts[1]] = bytes(buf.decBytes());
                cnts[1]++;
            }
            else { buf.skipValue(wire); } // skip value of unknown tag
        }
    } // end decoder Node

    struct Proof {
        Node[] nodes;   // tag: 1
    } // end struct Proof

    function decProof(bytes memory raw) internal pure returns (Proof memory m) {
        Pb.Buffer memory buf = Pb.fromBytes(raw);

        uint[] memory cnts = buf.cntTags(1);
        m.nodes = new Node[](cnts[1]);
        cnts[1] = 0;  // reset counter for later use
        
        uint tag;
        Pb.WireType wire;
        while (buf.hasMore()) {
            (tag, wire) = buf.decKey();
            if (false) {} // solidity has no switch/case
            else if (tag == 1) {
                m.nodes[cnts[1]] = decNode(buf.decBytes());
                cnts[1]++;
            }
            else { buf.skipValue(wire); } // skip value of unknown tag
        }
    } // end decoder Proof

    struct Punishment {
        address[] guardians;   // tag: 1
        address client;   // tag: 2
    } // end struct Punishment

    function decPunishment(bytes memory raw) internal pure returns (Punishment memory m) {
        Pb.Buffer memory buf = Pb.fromBytes(raw);

        uint[] memory cnts = buf.cntTags(2);
        m.guardians = new address[](cnts[1]);
        cnts[1] = 0;  // reset counter for later use
        
        uint tag;
        Pb.WireType wire;
        while (buf.hasMore()) {
            (tag, wire) = buf.decKey();
            if (false) {} // solidity has no switch/case
            else if (tag == 1) {
                m.guardians[cnts[1]] = Pb._address(buf.decBytes());
                cnts[1]++;
            }
            else if (tag == 2) {
                m.client = Pb._address(buf.decBytes());
            }
            else { buf.skipValue(wire); } // skip value of unknown tag
        }
    } // end decoder Punishment

}

